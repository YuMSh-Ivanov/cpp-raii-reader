# Работа с классами.

В этом домашнем задании Вам нужно класс `raii_reader`, предназначенный для чтения двоичных файлов. Пояснение, как работать с файлами, написано ниже. У данного класса должны быть следующие поля и методы:

1. **Явный** конструктор `raii_reader(const char* filename)` — создаёт `file_reader`, который читает из файла с именем `filename`. Для реализации см. `std::fopen`.
2. Конструктор `raii_reader()` — создаёт `filename`, не открывая никакой файл. Нужно чтобы можно было потом сделать `open`.
3. Статическое поле `raii_reader standard_input` — `file_reader`, который читает из стандартного потока вода (из консоли приложения).
4. Деструктор `~raii_reader()` — должен в соотвествии с идиомой RAII закрывать файл, если он был открыт. Закрывать стандартный поток вывода не надо.
5. Метод `bool is_opened()` — проверяет, соотвествует ли `file_reader` открытому файлу или стандартному потоку вывода.
6. Метод `bool open(const char* name)` — пытается открыть файл именем `name`. Если файл получилось открыть, но `file_reader` уже был открыт какой-то файл, старый файл закрывается. Возвращает `true`, если новый файл удалось открыть.
7. Метод `std::optional<unsigned char> read_char()` — пытается прочитать символ из файла. Если получается, возвращает его, иначе возвращает `std::nullopt`.
8. Метод `bool try_rewind()` — пытается "перемотать" файл в начало, чтобы начать читать его сначала. Если это действие успешно, возвращает `true`. Это может быть неуспешно, если файла не существует, или если чтение осуществляется из стандартного потока вывода на Linux.

В задании разрешено пользоваться только C API для взаимодействия с файлами (т.е. никаких `std::ifstream`).
Описание:
- `std::FILE*` — указатель на структуру, в которой хранится вся информация о файле. Всё взаимодействия с файлами осуществляется через такие указатели.
- `std::FILE* fopen(const char* filename, const char* mode)` — функция, которая пытается открыть файл с именем `filename` в нужном режиме. Вам нужно передать в качестве `mode` строку `"rb"` (режим двоичного чтения). Функция возвращает `nullptr`, если файл не получилось открыть.
- `int fclose(std::FILE* stream)` — функция, которая закрывает файл. Её возвращаемое значение можно игнорировать в этом задании.
- `stdin` — объект типа `std::FILE*`, представляюий собой "файл" для чтения из стандартного потока вывода.
- `int fgetc(std::FILE* stream)` — функция, которая пытается прочитать символ из файла. Если не получилось, возвращают `-1`. Иначе возвращают значение от 0 до 255, равное прочитанному символу.
- `int fseek(std::FILE* stream, long offset, int origin)` — функция, которая пытается начать читать файл из другого места. Чтобы читать сначала, надо в качестве `offset` передать `0`, а в качестве `origin` — константу `SEEK_SET`. Возвращает `0`, если перемотка прошла успешно.

Также в функции `read_char` нужно вернуть `std::optional<unsigned char>`. Это тип, который хранит либо `unsigned char`, либо ничего. Чтобы вернуть ничего, можно вернуть константу `std::nullopt`. Значение типа `unisigned char` само неявно преобразуется в `std::optional<unsigned char>`.

При выполненнии задания обратите внимание на следующее:
- Файл с классом и объявлениями методов должен называться `raii_reader.h`. Файл с определениями методов должен называться `raii_reader.cpp`. Оба должны лежать в папке `src`.
- Замечание: когда вы создадите свои cpp-файлы, по умолчанию их компилировать не будут. Чтобы их начали компилировать, добавьте их названия в CMakeLists.txt в строчку
  ```cmake
  add_executable(tests "conf-src/sanitizers_configure.cpp" "tests/test.cpp" вот-сюда-вот)
  ```
